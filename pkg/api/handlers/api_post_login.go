/*
 * Veritone Build and Release API
 *
 * Build and release API for Veritone
 *
 * API version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package handlers

import (
	"encoding/json"
	"golang.org/x/crypto/bcrypt"
	"net/http"

	log "github.com/sirupsen/logrus"

	"github.com/aeekayy/go-api-base/pkg/auth"
	"github.com/aeekayy/go-api-base/pkg/config"
	"github.com/aeekayy/go-api-base/pkg/models"
)

const (
	postLoginQueryCols = "username,password"
	//postLoginQueryDistinctCols = "service_id,environment_id"
	postLoginQueryTableName = "users"
)

// PostLogin post login handler object
type PostLogin struct {
	BaseHandler
}

// PostLoginRequest login request object
type PostLoginRequest struct {
	Username string `json:"username" yaml:"username"`
	Password string `json:"password" yaml:"password"`
}

// PostLoginResponseData login request response object
type PostLoginResponseData struct {
	Username string `json:"username" yaml:"username"`
	Token    string `json:"token" yaml:"token"`
}

// PostLoginResponse returns a response object with status and data
type PostLoginResponse struct {
	Status int                   `json:"status" yaml:"status"`
	Data   PostLoginResponseData `json:"data" yaml:"data"`
}

// ServeHTTP handler for PostLogin
func (h PostLogin) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	h.Name = "PostLoginRoute"
	h.Category = CategoryAuth

	var req PostLoginRequest
	var creds models.Credentials

	allowedOrigin, err := ReturnAccessControlAllowOrigin(h.CORS, r.Header.Get("Origin"))
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	if r.Method == http.MethodOptions {
		return
	}

	err = json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	if req.Username == "" || req.Password == "" {
		http.Error(w, "Invalid login details. Provide valid login details", http.StatusUnauthorized)
		return
	}

	// retrieve the result
	if err := h.DB.Raw("select "+postLoginQueryCols+" from "+postLoginQueryTableName+" WHERE username = ?;", req.Username).Scan(&creds).Error; err != nil {
		http.Error(w, "Query error", http.StatusBadRequest)
		return
	}

	if creds.Username == "" {
		http.Error(w, "Query error", http.StatusBadRequest)
		return
	}

	// to do. Add login attempt counter
	if err = bcrypt.CompareHashAndPassword([]byte(creds.Password), []byte(req.Password)); err != nil {
		http.Error(w, "Incorrect password", http.StatusUnauthorized)
		return
	}

	token, err := CreateToken(creds.Username, h.Config)
	if err != nil {
		http.Error(w, err.Error(), http.StatusUnprocessableEntity)
		return
	}

	// create data response
	response := PostLoginResponseData{
		Username: req.Username,
		Token:    token,
	}

	// wrap the result in a response
	resp := PostLoginResponse{
		Status: http.StatusOK,
		Data:   response,
	}

	respJSON, err := json.Marshal(resp)
	if err != nil {
		log.Error("Could not retrieve event errors")
		http.Error(w, "Could not retrieve data", http.StatusUnprocessableEntity)
		return
	}

	w.WriteHeader(http.StatusOK)

	_, err = w.Write([]byte(respJSON))

	if err != nil {
		log.Errorf("error sending response for %s: %s", h.Name, err)
	}
}

// CreateToken creates a signed JWT for user login
func CreateToken(username string, config *config.HTTPConfig) (string, error) {
	log.Info(username)
	jwtWrapper := auth.JwtWrapper{
		SecretKey:       config.Jwt.SecretKey,
		Issuer:          config.Jwt.Issuer,
		ExpirationHours: config.Jwt.ExpirationHours,
	}

	// generate the signed token
	signedToken, err := jwtWrapper.GenerateToken(username)
	if err != nil {
		return "", err
	}

	return signedToken, nil
}
