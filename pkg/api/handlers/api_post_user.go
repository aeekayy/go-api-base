/*
 * Veritone Build and Release API
 *
 * Build and release API for Veritone
 *
 * API version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package handlers

import (
	"encoding/json"
	"net/http"

	log "github.com/sirupsen/logrus"
	"gorm.io/gorm/clause"

	"github.com/aeekayy/go-api-base/pkg/models"
)

const (
	postUserQueryCols = "username"
	//postUserQueryDistinctCols = "service_id,environment_id"
	postUserQueryTableName = "users"
)

type PostUser struct {
	BaseHandler
}

type PostUserRequest struct {
	Username string `json:"username" yaml:"username"`
}

type PostUserResponse struct {
	Status int           `json:"status" yaml:"status"`
	Data   []models.User `json:"data" yaml:"data"`
}

func (h PostUser) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	h.Name = "PostUserRoute"
	h.Category = CategoryUser

	var req PostUserRequest
	var users []models.User

	allowedOrigin, err := ReturnAccessControlAllowOrigin(h.CORS, r.Header.Get("Origin"))
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	if r.Method == http.MethodOptions {
		return
	}

	err = json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// retrieve the result
	user := models.User{
		Username: req.Username,
	}

	// retrieve the result
	h.DB.Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "username"}},
		DoUpdates: clause.AssignmentColumns([]string{"updated_date_time"}),
	}).Select("Username", "Kvp").Create(&user)
	/*
		if err := h.DB.Raw("select " + postUserQueryCols + " from " + postUserQueryTableName + ";").Scan(&postUser).Error; err != nil {
			http.Error(w, "Query error", http.StatusBadRequest)
			return
		}*/

	// append the pipeline
	users = append(users, user)

	// wrap the result in a response
	resp := PostUserResponse{
		Status: http.StatusOK,
		Data:   users,
	}

	respJson, err := json.Marshal(resp)
	if err != nil {
		log.Error("Could not retrieve event errors")
		http.Error(w, "Could not retrieve data", http.StatusUnprocessableEntity)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte(respJson))
}
